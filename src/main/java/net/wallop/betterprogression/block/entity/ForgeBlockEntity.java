package net.wallop.betterprogression.block.entity;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;import net.fabricmc.fabric.api.screenhandler.v1.ExtendedScreenHandlerFactory;import net.minecraft.SharedConstants;import net.minecraft.block.Block;import net.minecraft.block.BlockState;import net.minecraft.block.Blocks;import net.minecraft.block.entity.BlockEntity;import net.minecraft.entity.ExperienceOrbEntity;import net.minecraft.entity.player.PlayerEntity;import net.minecraft.entity.player.PlayerInventory;import net.minecraft.inventory.Inventories;import net.minecraft.inventory.SidedInventory;import net.minecraft.inventory.SimpleInventory;import net.minecraft.item.Item;import net.minecraft.item.ItemConvertible;import net.minecraft.item.ItemStack;import net.minecraft.item.Items;import net.minecraft.nbt.NbtCompound;import net.minecraft.network.PacketByteBuf;import net.minecraft.recipe.RecipeEntry;import net.minecraft.recipe.RecipeManager;import net.minecraft.recipe.RecipeType;import net.minecraft.registry.Registries;import net.minecraft.registry.RegistryWrapper;import net.minecraft.registry.entry.RegistryEntry;import net.minecraft.registry.tag.ItemTags;import net.minecraft.registry.tag.TagKey;import net.minecraft.screen.NamedScreenHandlerFactory;import net.minecraft.screen.PropertyDelegate;import net.minecraft.screen.ScreenHandler;import net.minecraft.server.network.ServerPlayerEntity;import net.minecraft.server.world.ServerWorld;import net.minecraft.text.Text;import net.minecraft.util.Identifier;import net.minecraft.util.Util;import net.minecraft.util.collection.DefaultedList;import net.minecraft.util.math.BlockPos;import net.minecraft.util.math.Direction;import net.minecraft.util.math.MathHelper;import net.minecraft.util.math.Vec3d;import net.minecraft.world.World;import net.wallop.betterprogression.BetterProgression;import net.wallop.betterprogression.block.ForgeBlock;import net.wallop.betterprogression.block.ModBlockEntityType;import net.wallop.betterprogression.inventory.ForgeScreenHandler;import net.wallop.betterprogression.inventory.ImplementedInventory;import net.wallop.betterprogression.item.ModItems;import net.wallop.betterprogression.recipe.ForgeRecipe;import net.wallop.betterprogression.recipe.ForgeRecipeInput;import net.wallop.betterprogression.util.ModTags;import org.jetbrains.annotations.Nullable;import java.util.List;import java.util.Map;import java.util.NoSuchElementException;import java.util.Optional;public class ForgeBlockEntity extends BlockEntity implements ExtendedScreenHandlerFactory<BlockPos>, ImplementedInventory, SidedInventory {    private static final int INPUT1_SLOT = 0;    private static final int INPUT2_SLOT = 1;    private static final int UPGRADE_SLOT = 2;    private static final int FUEL_SLOT = 3;    private static final int OUTPUT_SLOT = 4;    private static final int[] TOP_SLOTS = new int[]{0, 1};    private static final int[] BOTTOM_SLOTS = new int[]{4};    private static final int[] SIDE_SLOTS = new int[]{3, 2};    int burnTime;    int fuelTime;    int cookTime;    int cookTimeTotal;    @Nullable    private static volatile Map<Item, Integer> fuelTimes;    private DefaultedList<ItemStack> inventory = DefaultedList.ofSize(5, ItemStack.EMPTY);    protected final PropertyDelegate propertyDelegate;    public ForgeBlockEntity(BlockPos pos, BlockState state) {        super(ModBlockEntityType.FORGE_BLOCK_ENTITY, pos, state);        this.propertyDelegate = new PropertyDelegate() {            @Override            public int get(int index) {                return switch (index) {                    case 0 -> ForgeBlockEntity.this.burnTime;                    case 1 -> ForgeBlockEntity.this.fuelTime;                    case 2 -> ForgeBlockEntity.this.cookTime;                    case 3 -> ForgeBlockEntity.this.cookTimeTotal;                    default -> 0;                };            }            @Override            public void set(int index, int value) {                switch (index) {                    case 0 -> ForgeBlockEntity.this.burnTime = value;                    case 1 -> ForgeBlockEntity.this.fuelTime = value;                    case 2 -> ForgeBlockEntity.this.cookTime = value;                    case 3 -> ForgeBlockEntity.this.cookTimeTotal = value;                }            }            @Override            public int size() {                return 4;            }        };    }    private final Object2IntOpenHashMap<Identifier> recipesUsed = new Object2IntOpenHashMap<>();    public static void clearFuelTimes() {        fuelTimes = null;    }    public static Map<Item, Integer> createFuelTimeMap() {        Map<Item, Integer> map = fuelTimes;        if (map != null) {            return map;        } else {            Map<Item, Integer> map2 = Maps.<Item, Integer>newLinkedHashMap();            addFuel(map2, Items.LAVA_BUCKET, 20000);            addFuel(map2, Blocks.COAL_BLOCK, 16000);            addFuel(map2, Items.BLAZE_ROD, 2400);            addFuel(map2, Items.COAL, 1600);            addFuel(map2, Items.CHARCOAL, 1600);            addFuel(map2, ItemTags.LOGS, 300);            addFuel(map2, ItemTags.BAMBOO_BLOCKS, 300);            addFuel(map2, ItemTags.PLANKS, 300);            addFuel(map2, Blocks.BAMBOO_MOSAIC, 300);            addFuel(map2, ItemTags.WOODEN_STAIRS, 300);            addFuel(map2, Blocks.BAMBOO_MOSAIC_STAIRS, 300);            addFuel(map2, ItemTags.WOODEN_SLABS, 150);            addFuel(map2, Blocks.BAMBOO_MOSAIC_SLAB, 150);            addFuel(map2, ItemTags.WOODEN_TRAPDOORS, 300);            addFuel(map2, ItemTags.WOODEN_PRESSURE_PLATES, 300);            addFuel(map2, ItemTags.WOODEN_FENCES, 300);            addFuel(map2, ItemTags.FENCE_GATES, 300);            addFuel(map2, Blocks.NOTE_BLOCK, 300);            addFuel(map2, Blocks.BOOKSHELF, 300);            addFuel(map2, Blocks.CHISELED_BOOKSHELF, 300);            addFuel(map2, Blocks.LECTERN, 300);            addFuel(map2, Blocks.JUKEBOX, 300);            addFuel(map2, Blocks.CHEST, 300);            addFuel(map2, Blocks.TRAPPED_CHEST, 300);            addFuel(map2, Blocks.CRAFTING_TABLE, 300);            addFuel(map2, Blocks.DAYLIGHT_DETECTOR, 300);            addFuel(map2, ItemTags.BANNERS, 300);            addFuel(map2, Items.BOW, 300);            addFuel(map2, Items.FISHING_ROD, 300);            addFuel(map2, Blocks.LADDER, 300);            addFuel(map2, ItemTags.SIGNS, 200);            addFuel(map2, ItemTags.HANGING_SIGNS, 800);            addFuel(map2, Items.WOODEN_SHOVEL, 200);            addFuel(map2, Items.WOODEN_SWORD, 200);            addFuel(map2, Items.WOODEN_HOE, 200);            addFuel(map2, Items.WOODEN_AXE, 200);            addFuel(map2, Items.WOODEN_PICKAXE, 200);            addFuel(map2, ItemTags.WOODEN_DOORS, 200);            addFuel(map2, ItemTags.BOATS, 1200);            addFuel(map2, ItemTags.WOOL, 100);            addFuel(map2, ItemTags.WOODEN_BUTTONS, 100);            addFuel(map2, Items.STICK, 100);            addFuel(map2, ItemTags.SAPLINGS, 100);            addFuel(map2, Items.BOWL, 100);            addFuel(map2, ItemTags.WOOL_CARPETS, 67);            addFuel(map2, Blocks.DRIED_KELP_BLOCK, 4001);            addFuel(map2, Items.CROSSBOW, 300);            addFuel(map2, Blocks.BAMBOO, 50);            addFuel(map2, Blocks.DEAD_BUSH, 100);            addFuel(map2, Blocks.SCAFFOLDING, 50);            addFuel(map2, Blocks.LOOM, 300);            addFuel(map2, Blocks.BARREL, 300);            addFuel(map2, Blocks.CARTOGRAPHY_TABLE, 300);            addFuel(map2, Blocks.FLETCHING_TABLE, 300);            addFuel(map2, Blocks.SMITHING_TABLE, 300);            addFuel(map2, Blocks.COMPOSTER, 300);            addFuel(map2, Blocks.AZALEA, 100);            addFuel(map2, Blocks.FLOWERING_AZALEA, 100);            addFuel(map2, Blocks.MANGROVE_ROOTS, 300);            fuelTimes = map2;            return map2;        }    }    private static boolean isNonFlammableWood(Item item) {        return item.getRegistryEntry().isIn(ItemTags.NON_FLAMMABLE_WOOD);    }    private static void addFuel(Map<Item, Integer> fuelTimes, TagKey<Item> tag, int fuelTime) {        for (RegistryEntry<Item> registryEntry : Registries.ITEM.iterateEntries(tag)) {            if (!isNonFlammableWood(registryEntry.value())) {                fuelTimes.put(registryEntry.value(), fuelTime);            }        }    }    private static void addFuel(Map<Item, Integer> fuelTimes, ItemConvertible item, int fuelTime) {        Item item2 = item.asItem();        if (isNonFlammableWood(item2)) {            if (SharedConstants.isDevelopment) {                throw (IllegalStateException) Util.throwOrPause(                        new IllegalStateException(                                "A developer tried to explicitly make fire resistant item " + item2.getName(null).getString() + " a furnace fuel. That will not work!"                        )                );            }        } else {            fuelTimes.put(item2, fuelTime);        }    }    private boolean isBurning() {        return this.burnTime > 0;    }    @Override    public DefaultedList<ItemStack> getItems() {        return inventory;    }    @Override    public ScreenHandler createMenu(int syncId, PlayerInventory playerInventory, PlayerEntity player) {        return new ForgeScreenHandler(syncId, playerInventory, this, this.propertyDelegate);    }    @Override    public Text getDisplayName() {        return Text.translatable(getCachedState().getBlock().getTranslationKey());    }    @Override    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {        super.readNbt(nbt, registryLookup);        this.inventory = DefaultedList.ofSize(this.size(), ItemStack.EMPTY);        Inventories.readNbt(nbt, inventory, registryLookup);        this.burnTime = nbt.getShort("BurnTime");        this.cookTime = nbt.getShort("CookTime");        this.cookTimeTotal = nbt.getShort("CookTimeTotal");        this.fuelTime = this.getFuelTime(this.inventory.get(FUEL_SLOT));        NbtCompound nbtCompound = nbt.getCompound("RecipesUsed");        for (String string : nbtCompound.getKeys()) {            this.recipesUsed.put(Identifier.of(string), nbtCompound.getInt(string));        }    }    @Override    public void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {        super.writeNbt(nbt, registryLookup);        nbt.putShort("BurnTime", (short)this.burnTime);        nbt.putShort("CookTime", (short)this.cookTime);        nbt.putShort("CookTimeTotal", (short)this.cookTimeTotal);        Inventories.writeNbt(nbt, inventory, registryLookup);        NbtCompound nbtCompound = new NbtCompound();        this.recipesUsed.forEach((identifier, count) -> nbtCompound.putInt(identifier.toString(), count));        nbt.put("RecipesUsed", nbtCompound);    }    public boolean isIngredientRequired(int index) {        if (getCurrentRecipe().isPresent()) {            boolean isIngredientRequired = !getCurrentRecipe().get().value().getIngredients().get(index).test(ModItems.EMPTY_SLOT.getDefaultStack());            //BetterProgression.LOGGER.info("Ingredient " + index + " required for recipe with result " + getCurrentRecipe().get().value().getResult(null).getItem().toString() + "? : " + isIngredientRequired);            return isIngredientRequired;        } else {            //BetterProgression.LOGGER.info("Current recipe not present");            return false;        }    }    public void tick(World world, BlockPos pos, BlockState state, ForgeBlockEntity blockEntity) {        if (world.isClient()) {            return;        }        boolean bl = blockEntity.isBurning();        boolean bl2 = false;        //BetterProgression.LOGGER.info("====== Forge Tick Start ======");        if (blockEntity.isBurning()) {            blockEntity.burnTime--;            //BetterProgression.LOGGER.warn("isBurning true. burnTime = " + blockEntity.burnTime + "\ncookTime = " + cookTime + "\ncookTimeTotal = " + cookTimeTotal);        } //else BetterProgression.LOGGER.warn("isBurning false. burnTime = " + burnTime + "\ncookTime = " + cookTime + "\ncookTimeTotal = " + cookTimeTotal);        ItemStack fuelStack = blockEntity.inventory.get(FUEL_SLOT);        ItemStack input1Stack = blockEntity.inventory.get(INPUT1_SLOT);        ItemStack input2Stack = blockEntity.inventory.get(INPUT2_SLOT);        ItemStack upgradeStack = blockEntity.inventory.get(UPGRADE_SLOT);        boolean bl3 = !input1Stack.isEmpty();        //BetterProgression.LOGGER.info("Input 1 present? " + bl3);        boolean bl4 = !fuelStack.isEmpty();        //BetterProgression.LOGGER.info("Fuel present? " + bl4);        boolean bl5 = !input2Stack.isEmpty();        //BetterProgression.LOGGER.info("Input 2 present? " + bl5);        boolean bl6 = !upgradeStack.isEmpty();        //BetterProgression.LOGGER.info("upgrade present? " + bl6);        boolean input1Required = isIngredientRequired(INPUT1_SLOT); //true        boolean input2Required = isIngredientRequired(INPUT2_SLOT); // true        boolean upgradeRequired = isIngredientRequired(UPGRADE_SLOT); // true        boolean recipeRequirementsMet = bl3 == input1Required && bl5 == input2Required && bl6 == upgradeRequired && bl3;        //BetterProgression.LOGGER.info("recipeRequirementsMet " + recipeRequirementsMet);        if (blockEntity.isBurning() || recipeRequirementsMet && bl4) {            ItemStack recipeResultItemStack;            if (getCurrentRecipe().isPresent() && recipeRequirementsMet) {                recipeResultItemStack = getCurrentRecipe().get().value().getResult(null);                //BetterProgression.LOGGER.info("Requirements met, recipeResultItemStack = " + recipeResultItemStack.getItem().toString());                blockEntity.cookTimeTotal = getCookTime(world, blockEntity);            } else {                recipeResultItemStack = null;            }            int i = blockEntity.getMaxCountPerStack();            if (!blockEntity.isBurning() && canAcceptRecipeOutput(recipeResultItemStack, blockEntity)) {                blockEntity.burnTime = blockEntity.getFuelTime(fuelStack);                blockEntity.fuelTime = blockEntity.burnTime;                if (blockEntity.isBurning()) {                    bl2 = true;                    if (bl4) {                        Item fuelItem = fuelStack.getItem();                        fuelStack.decrement(1);                        if (fuelStack.isEmpty()) {                            Item item2 = fuelItem.getRecipeRemainder();                            blockEntity.inventory.set(FUEL_SLOT, item2 == null ? ItemStack.EMPTY : new ItemStack(item2));                        }                    }                }            }            if (blockEntity.isBurning() && canAcceptRecipeOutput(recipeResultItemStack, blockEntity)) {                blockEntity.cookTime++;                if (blockEntity.cookTime == blockEntity.cookTimeTotal) {                    blockEntity.cookTime = 0;                    blockEntity.cookTimeTotal = getCookTime(world, blockEntity);                    //BetterProgression.LOGGER.info("cookTimeTotal = " + cookTimeTotal);                    Optional<RecipeEntry<ForgeRecipe>> optionalRecipeEntry = getCurrentRecipe();                    if (craftRecipe(recipeResultItemStack, blockEntity.inventory, i, blockEntity)) {                        //BetterProgression.LOGGER.info("Crafting successful at " + pos);                        if (optionalRecipeEntry.isPresent()) {                            RecipeEntry<ForgeRecipe> recipeEntry = optionalRecipeEntry.get();                            BetterProgression.LOGGER.info("recipeEntry:" + recipeEntry.id());                            blockEntity.setLastRecipe(recipeEntry);                        }                    }                    bl2 = true;                }            } else {                blockEntity.cookTime = 0;            }        } else if (!blockEntity.isBurning() && blockEntity.cookTime > 0) {            blockEntity.cookTime = MathHelper.clamp(blockEntity.cookTime - 2, 0, blockEntity.cookTimeTotal);        }        if (bl != blockEntity.isBurning()) {            bl2 = true;            state = state.with(ForgeBlock.LIT, Boolean.valueOf(blockEntity.isBurning()));            world.setBlockState(pos, state, Block.NOTIFY_ALL);        }        if (bl2) {            markDirty(world, pos, state);        }    }    private void setLastRecipe(@Nullable RecipeEntry<?> recipe) {        if (recipe != null) {            Identifier identifier = recipe.id();            BetterProgression.LOGGER.info("Last Recipe Set: " + identifier);            this.recipesUsed.addTo(identifier, 1);        }    }    @Nullable    public RecipeEntry<?> getLastRecipe() {return null;}    public void dropExperienceForRecipesUsed(ServerPlayerEntity player) {        List<RecipeEntry<?>> list = this.getRecipesUsedAndDropExperience(player.getServerWorld(), player.getPos());        player.unlockRecipes(list);        for (RecipeEntry<?> recipeEntry : list) {            if (recipeEntry != null) {                player.onRecipeCrafted(recipeEntry, this.inventory);            }        }        this.recipesUsed.clear();    }    private List<RecipeEntry<?>> getRecipesUsedAndDropExperience(ServerWorld world, Vec3d pos) {        List<RecipeEntry<?>> list = Lists.<RecipeEntry<?>>newArrayList();        for (Entry<Identifier> entry : this.recipesUsed.object2IntEntrySet()) {            world.getRecipeManager().get((Identifier) entry.getKey()).ifPresent(recipe -> {                list.add(recipe);                dropExperience(world, pos, entry.getIntValue(), ((ForgeRecipe) recipe.value()).getExperience());            });        }        return list;    }    private void dropExperience(ServerWorld world, Vec3d pos, int multiplier, float experience) {        int i = MathHelper.floor((float) multiplier * experience);        float f = MathHelper.fractionalPart((float) multiplier * experience);        if (f != 0.0f && Math.random() < (double) f) {            i++;        }        ExperienceOrbEntity.spawn(world, pos, i);    }    private static boolean craftRecipe(ItemStack result, DefaultedList<ItemStack> slots, int count, ForgeBlockEntity blockEntity) {        if (result != null && canAcceptRecipeOutput(result, blockEntity)) {            ItemStack input1 = slots.get(INPUT1_SLOT);            ItemStack input2 = slots.get(INPUT2_SLOT);            ItemStack output = slots.get(OUTPUT_SLOT);            if (output.isEmpty()) {                slots.set(OUTPUT_SLOT, result.copy());            } else if (ItemStack.areItemsAndComponentsEqual(output, result)) {                output.increment(1);            }            input1.decrement(1);            input2.decrement(1);            return true;        } else {            return false;        }    }    protected int getFuelTime(ItemStack fuel) {        if (fuel.isEmpty()) {            return 0;        } else {            Item item = fuel.getItem();            return (Integer)createFuelTimeMap().getOrDefault(item, 0);        }    }    private int getCookTime(World world, ForgeBlockEntity forge) {        Optional<RecipeEntry<ForgeRecipe>> recipe = getCurrentRecipe();        try {            //BetterProgression.LOGGER.info("Cooking time fetched : " + recipe.get().value().getCookingTime());            return recipe.get().value().getCookingTime();        } catch (NoSuchElementException e) {            //BetterProgression.LOGGER.error("Cook time fetch failed", e);            return 0;        }    }    public static boolean canUseAsFuel(ItemStack stack) {        return createFuelTimeMap().containsKey(stack.getItem());    }    private Optional<RecipeEntry<ForgeRecipe>> getCurrentRecipe() {        SimpleInventory inv = new SimpleInventory(this.size());        for (int i = 0; i < this.size(); i++) {            if (this.getStack(i) == ItemStack.EMPTY) {                inv.setStack(i, ModItems.EMPTY_SLOT.getDefaultStack());            } else {                inv.setStack(i, this.getStack(i));            }        }        //BetterProgression.LOGGER.info("Checking current recipe: " + inv);        Optional<RecipeEntry<ForgeRecipe>> currentRecipe = getWorld().getRecipeManager().getFirstMatch(                ForgeRecipe.ForgeRecipeType.INSTANCE,                new ForgeRecipeInput(                        inv.getStack(INPUT1_SLOT),                        inv.getStack(INPUT2_SLOT),                        inv.getStack(UPGRADE_SLOT)                ), getWorld());        return currentRecipe;    }    private static boolean canAcceptRecipeOutput(ItemStack itemStack, ForgeBlockEntity blockEntity) {        if (itemStack == null) {            return false;        } else {            return blockEntity.getStack(OUTPUT_SLOT).getItem() == itemStack.getItem() || blockEntity.getStack(OUTPUT_SLOT).isEmpty()                    && blockEntity.getStack(OUTPUT_SLOT).getCount() + itemStack.getCount() <= blockEntity.getStack(OUTPUT_SLOT).getMaxCount();        }    }    @Override    public BlockPos getScreenOpeningData(ServerPlayerEntity player) {        return this.pos;    }    @Override    public int[] getAvailableSlots(Direction side) {        if (side == Direction.DOWN) {            return BOTTOM_SLOTS;        } else {            return side == Direction.UP ? TOP_SLOTS : SIDE_SLOTS;        }    }    @Override    public boolean canInsert(int slot, ItemStack stack, @Nullable Direction dir) {        return this.isValid(slot, stack);    }    @Override    public boolean canExtract(int slot, ItemStack stack, Direction dir) {        return dir == Direction.DOWN;    }    @Override    public boolean isValid(int slot, ItemStack stack) {        return switch (slot) {            case (0) -> stack.isIn(ModTags.Items.FORGE_SLOT_0_ITEMS);            case (1) -> stack.isIn(ModTags.Items.FORGE_SLOT_1_ITEMS);            case (2) -> stack.isIn(ModTags.Items.FORGE_SLOT_2_ITEMS);            case (3) -> canUseAsFuel(stack);            default -> false;        };    }}