package net.wallop.betterprogression.block.entity;import com.google.common.collect.Maps;import net.minecraft.SharedConstants;import net.minecraft.Util;import net.minecraft.core.BlockPos;import net.minecraft.core.Holder;import net.minecraft.core.HolderLookup;import net.minecraft.core.NonNullList;import net.minecraft.core.registries.BuiltInRegistries;import net.minecraft.nbt.CompoundTag;import net.minecraft.network.chat.Component;import net.minecraft.tags.ItemTags;import net.minecraft.tags.TagKey;import net.minecraft.util.Mth;import net.minecraft.world.ContainerHelper;import net.minecraft.world.MenuProvider;import net.minecraft.world.SimpleContainer;import net.minecraft.world.entity.player.Inventory;import net.minecraft.world.entity.player.Player;import net.minecraft.world.inventory.AbstractContainerMenu;import net.minecraft.world.inventory.ContainerData;import net.minecraft.world.item.Item;import net.minecraft.world.item.ItemStack;import net.minecraft.world.item.Items;import net.minecraft.world.item.crafting.RecipeHolder;import net.minecraft.world.level.ItemLike;import net.minecraft.world.level.Level;import net.minecraft.world.level.block.Block;import net.minecraft.world.level.block.Blocks;import net.minecraft.world.level.block.entity.BlockEntity;import net.minecraft.world.level.block.state.BlockState;import net.wallop.betterprogression.BetterProgression;import net.wallop.betterprogression.block.ForgeBlock;import net.wallop.betterprogression.block.ModBlockEntityType;import net.wallop.betterprogression.inventory.ForgeScreenHandler;import net.wallop.betterprogression.inventory.ImplementedInventory;import net.wallop.betterprogression.item.ModItems;import net.wallop.betterprogression.recipe.ForgeRecipe;import net.wallop.betterprogression.recipe.ForgeRecipeInput;import net.wallop.betterprogression.util.ModTags;import org.jetbrains.annotations.Nullable;import java.util.Map;import java.util.NoSuchElementException;import java.util.Optional;public class ForgeBlockEntity extends BlockEntity implements ImplementedInventory, MenuProvider {    private static final int INPUT1_SLOT = 0;    private static final int INPUT2_SLOT = 1;    private static final int UPGRADE_SLOT = 2;    private static final int FUEL_SLOT = 3;    private static final int OUTPUT_SLOT = 4;    int burnTime;    int fuelTime;    int cookTime;    int cookTimeTotal;    @Nullable    private static volatile Map<Item, Integer> fuelTimes;    private NonNullList<ItemStack> inventory = NonNullList.withSize(5, ItemStack.EMPTY);    protected final ContainerData propertyDelegate;    public ForgeBlockEntity(BlockPos pos, BlockState state) {        super(ModBlockEntityType.FORGE_BLOCK_ENTITY, pos, state);        this.propertyDelegate = new ContainerData() {            @Override            public int get(int index) {                return switch (index) {                    case 0 -> ForgeBlockEntity.this.burnTime;                    case 1 -> ForgeBlockEntity.this.fuelTime;                    case 2 -> ForgeBlockEntity.this.cookTime;                    case 3 -> ForgeBlockEntity.this.cookTimeTotal;                    default -> 0;                };            }            @Override            public void set(int index, int value) {                switch (index) {                    case 0 -> ForgeBlockEntity.this.burnTime = value;                    case 1 -> ForgeBlockEntity.this.fuelTime = value;                    case 2 -> ForgeBlockEntity.this.cookTime = value;                    case 3 -> ForgeBlockEntity.this.cookTimeTotal = value;                }            }            @Override            public int getCount() {                return 4;            }        };    }    public static void clearFuelTimes() {        fuelTimes = null;    }    public static Map<Item, Integer> createFuelTimeMap() {        Map<Item, Integer> map = fuelTimes;        if (map != null) {            return map;        } else {            Map<Item, Integer> map2 = Maps.<Item, Integer>newLinkedHashMap();            addFuel(map2, Items.LAVA_BUCKET, 20000);            addFuel(map2, Blocks.COAL_BLOCK, 16000);            addFuel(map2, Items.BLAZE_ROD, 2400);            addFuel(map2, Items.COAL, 1600);            addFuel(map2, Items.CHARCOAL, 1600);            addFuel(map2, ItemTags.LOGS, 300);            addFuel(map2, ItemTags.BAMBOO_BLOCKS, 300);            addFuel(map2, ItemTags.PLANKS, 300);            addFuel(map2, Blocks.BAMBOO_MOSAIC, 300);            addFuel(map2, ItemTags.WOODEN_STAIRS, 300);            addFuel(map2, Blocks.BAMBOO_MOSAIC_STAIRS, 300);            addFuel(map2, ItemTags.WOODEN_SLABS, 150);            addFuel(map2, Blocks.BAMBOO_MOSAIC_SLAB, 150);            addFuel(map2, ItemTags.WOODEN_TRAPDOORS, 300);            addFuel(map2, ItemTags.WOODEN_PRESSURE_PLATES, 300);            addFuel(map2, ItemTags.WOODEN_FENCES, 300);            addFuel(map2, ItemTags.FENCE_GATES, 300);            addFuel(map2, Blocks.NOTE_BLOCK, 300);            addFuel(map2, Blocks.BOOKSHELF, 300);            addFuel(map2, Blocks.CHISELED_BOOKSHELF, 300);            addFuel(map2, Blocks.LECTERN, 300);            addFuel(map2, Blocks.JUKEBOX, 300);            addFuel(map2, Blocks.CHEST, 300);            addFuel(map2, Blocks.TRAPPED_CHEST, 300);            addFuel(map2, Blocks.CRAFTING_TABLE, 300);            addFuel(map2, Blocks.DAYLIGHT_DETECTOR, 300);            addFuel(map2, ItemTags.BANNERS, 300);            addFuel(map2, Items.BOW, 300);            addFuel(map2, Items.FISHING_ROD, 300);            addFuel(map2, Blocks.LADDER, 300);            addFuel(map2, ItemTags.SIGNS, 200);            addFuel(map2, ItemTags.HANGING_SIGNS, 800);            addFuel(map2, Items.WOODEN_SHOVEL, 200);            addFuel(map2, Items.WOODEN_SWORD, 200);            addFuel(map2, Items.WOODEN_HOE, 200);            addFuel(map2, Items.WOODEN_AXE, 200);            addFuel(map2, Items.WOODEN_PICKAXE, 200);            addFuel(map2, ItemTags.WOODEN_DOORS, 200);            addFuel(map2, ItemTags.BOATS, 1200);            addFuel(map2, ItemTags.WOOL, 100);            addFuel(map2, ItemTags.WOODEN_BUTTONS, 100);            addFuel(map2, Items.STICK, 100);            addFuel(map2, ItemTags.SAPLINGS, 100);            addFuel(map2, Items.BOWL, 100);            addFuel(map2, ItemTags.WOOL_CARPETS, 67);            addFuel(map2, Blocks.DRIED_KELP_BLOCK, 4001);            addFuel(map2, Items.CROSSBOW, 300);            addFuel(map2, Blocks.BAMBOO, 50);            addFuel(map2, Blocks.DEAD_BUSH, 100);            addFuel(map2, Blocks.SCAFFOLDING, 50);            addFuel(map2, Blocks.LOOM, 300);            addFuel(map2, Blocks.BARREL, 300);            addFuel(map2, Blocks.CARTOGRAPHY_TABLE, 300);            addFuel(map2, Blocks.FLETCHING_TABLE, 300);            addFuel(map2, Blocks.SMITHING_TABLE, 300);            addFuel(map2, Blocks.COMPOSTER, 300);            addFuel(map2, Blocks.AZALEA, 100);            addFuel(map2, Blocks.FLOWERING_AZALEA, 100);            addFuel(map2, Blocks.MANGROVE_ROOTS, 300);            fuelTimes = map2;            return map2;        }    }    private static boolean isNonFlammableWood(Item item) {        return item.builtInRegistryHolder().is(ItemTags.NON_FLAMMABLE_WOOD);    }    private static void addFuel(Map<Item, Integer> fuelTimes, TagKey<Item> tag, int fuelTime) {        for (Holder<Item> registryEntry : BuiltInRegistries.ITEM.getTagOrEmpty(tag)) {            if (!isNonFlammableWood(registryEntry.value())) {                fuelTimes.put(registryEntry.value(), fuelTime);            }        }    }    private static void addFuel(Map<Item, Integer> fuelTimes, ItemLike item, int fuelTime) {        Item item2 = item.asItem();        if (isNonFlammableWood(item2)) {            if (SharedConstants.IS_RUNNING_IN_IDE) {                throw (IllegalStateException) Util.pauseInIde(                        new IllegalStateException(                                "A developer tried to explicitly make fire resistant item " + item2.getName(null).getString() + " a furnace fuel. That will not work!"                        )                );            }        } else {            fuelTimes.put(item2, fuelTime);        }    }    private boolean isBurning() {        return this.burnTime > 0;    }    @Override    public NonNullList<ItemStack> getItems() {        return inventory;    }    @Override    public AbstractContainerMenu createMenu(int syncId, Inventory playerInventory, Player player) {        return new ForgeScreenHandler(syncId, playerInventory, this);    }    @Override    public Component getDisplayName() {        return Component.translatable(getBlockState().getBlock().getDescriptionId());    }    @Override    public void loadAdditional(CompoundTag nbt, HolderLookup.Provider registryLookup) {        super.loadAdditional(nbt, registryLookup);        this.inventory = NonNullList.withSize(this.getContainerSize(), ItemStack.EMPTY);        ContainerHelper.loadAllItems(nbt, inventory, registryLookup);        this.burnTime = nbt.getShort("BurnTime");        this.cookTime = nbt.getShort("CookTime");        this.cookTimeTotal = nbt.getShort("CookTimeTotal");        this.fuelTime = this.getFuelTime(this.inventory.get(FUEL_SLOT));        //NbtCompound nbtCompound = nbt.getCompound("RecipesUsed");//        for (String string : nbtCompound.getKeys()) {//            this.recipesUsed.put(Identifier.of(string), nbtCompound.getInt(string));//        }    }    @Override    public void saveAdditional(CompoundTag nbt, HolderLookup.Provider registryLookup) {        super.saveAdditional(nbt, registryLookup);        nbt.putShort("BurnTime", (short)this.burnTime);        nbt.putShort("CookTime", (short)this.cookTime);        nbt.putShort("CookTimeTotal", (short)this.cookTimeTotal);        ContainerHelper.saveAllItems(nbt, inventory, registryLookup);        //NbtCompound nbtCompound = new NbtCompound();        //this.recipesUsed.forEach((identifier, count) -> nbtCompound.putInt(identifier.toString(), count));        //nbt.put("RecipesUsed", nbtCompound);    }    public boolean isIngredientRequired(int index) {        if (getCurrentRecipe().isPresent()) {            boolean isIngredientRequired = !getCurrentRecipe().get().value().getIngredients().get(index).test(ModItems.EMPTY_SLOT.getDefaultInstance());            BetterProgression.LOGGER.info("Ingredient " + index + " required for recipe with result " + getCurrentRecipe().get().value().getResultItem(null).getItem().toString() + "? : " + isIngredientRequired);            return isIngredientRequired;        } else return false;    }    public void tick(Level world, BlockPos pos, BlockState state, ForgeBlockEntity blockEntity) {        if (world.isClientSide()) {            return;        }        boolean bl = blockEntity.isBurning();        boolean bl2 = false;        BetterProgression.LOGGER.info("====== Forge Tick Start ======");        if (blockEntity.isBurning()) {            blockEntity.burnTime--;            BetterProgression.LOGGER.warn("isBurning true. burnTime = " + blockEntity.burnTime + "\ncookTime = " + cookTime + "\ncookTimeTotal = " + cookTimeTotal);        } else BetterProgression.LOGGER.warn("isBurning false. burnTime = " + burnTime + "\ncookTime = " + cookTime + "\ncookTimeTotal = " + cookTimeTotal);        ItemStack fuelStack = blockEntity.inventory.get(FUEL_SLOT);        ItemStack input1Stack = blockEntity.inventory.get(INPUT1_SLOT);        ItemStack input2Stack = blockEntity.inventory.get(INPUT2_SLOT);        ItemStack upgradeStack = blockEntity.inventory.get(UPGRADE_SLOT);        boolean bl3 = !input1Stack.isEmpty();        BetterProgression.LOGGER.info("Input 1 present? " + bl3);        boolean bl4 = !fuelStack.isEmpty();        BetterProgression.LOGGER.info("Fuel present? " + bl4);        boolean bl5 = !input2Stack.isEmpty();        BetterProgression.LOGGER.info("Input 2 present? " + bl5);        boolean bl6 = !upgradeStack.isEmpty();        BetterProgression.LOGGER.info("upgrade present? " + bl6);        boolean input1Required = isIngredientRequired(INPUT1_SLOT); //true        boolean input2Required = isIngredientRequired(INPUT2_SLOT); // true        boolean upgradeRequired = isIngredientRequired(UPGRADE_SLOT); // true        boolean recipeRequirementsMet = bl3 == input1Required && bl5 == input2Required && bl6 == upgradeRequired && bl3;        BetterProgression.LOGGER.info("recipeRequirementsMet " + recipeRequirementsMet);        if (blockEntity.isBurning() || recipeRequirementsMet && bl4) {            ItemStack recipeResultItemStack;            if (getCurrentRecipe().isPresent() && recipeRequirementsMet) {                recipeResultItemStack = getCurrentRecipe().get().value().getResultItem(null);                BetterProgression.LOGGER.info("Requirements met, recipeResultItemStack = " + recipeResultItemStack.getItem().toString());                blockEntity.cookTimeTotal = getCookTime(world, blockEntity);            } else {                recipeResultItemStack = null;            }            int i = blockEntity.getMaxStackSize();            if (!blockEntity.isBurning() && canAcceptRecipeOutput(recipeResultItemStack, blockEntity)) {                blockEntity.burnTime = blockEntity.getFuelTime(fuelStack);                blockEntity.fuelTime = blockEntity.burnTime;                if (blockEntity.isBurning()) {                    bl2 = true;                    if (bl4) {                        Item fuelItem = fuelStack.getItem();                        fuelStack.shrink(1);                        if (fuelStack.isEmpty()) {                            Item item2 = fuelItem.getCraftingRemainingItem();                            blockEntity.inventory.set(1, item2 == null ? ItemStack.EMPTY : new ItemStack(item2));                        }                    }                }            }            if (blockEntity.isBurning() && canAcceptRecipeOutput(recipeResultItemStack, blockEntity)) {                blockEntity.cookTime++;                if (blockEntity.cookTime == blockEntity.cookTimeTotal) {                    blockEntity.cookTime = 0;                    blockEntity.cookTimeTotal = getCookTime(world, blockEntity);                    BetterProgression.LOGGER.info("cookTimeTotal = " + cookTimeTotal);                    if (craftRecipe(recipeResultItemStack, blockEntity.inventory, i, blockEntity)) {                        BetterProgression.LOGGER.info("Crafting successful at " + pos);                        //blockEntity.setLastRecipe(getCurrentRecipe());                    }                    bl2 = true;                }            } else {                blockEntity.cookTime = 0;            }        } else if (!blockEntity.isBurning() && blockEntity.cookTime > 0) {            blockEntity.cookTime = Mth.clamp(blockEntity.cookTime - 2, 0, blockEntity.cookTimeTotal);        }        if (bl != blockEntity.isBurning()) {            bl2 = true;            state = state.setValue(ForgeBlock.LIT, Boolean.valueOf(blockEntity.isBurning()));            world.setBlock(pos, state, Block.UPDATE_ALL);        }        if (bl2) {            setChanged(world, pos, state);        }    }    private static boolean craftRecipe(ItemStack result, NonNullList<ItemStack> slots, int count, ForgeBlockEntity blockEntity) {        if (result != null && canAcceptRecipeOutput(result, blockEntity)) {            ItemStack input1 = slots.get(INPUT1_SLOT);            ItemStack input2 = slots.get(INPUT2_SLOT);            ItemStack output = slots.get(OUTPUT_SLOT);            if (output.isEmpty()) {                slots.set(OUTPUT_SLOT, result.copy());            } else if (ItemStack.isSameItemSameComponents(output, result)) {                output.grow(1);            }            input1.shrink(1);            input2.shrink(1);            return true;        } else {            return false;        }    }    protected int getFuelTime(ItemStack fuel) {        if (fuel.isEmpty()) {            return 0;        } else {            Item item = fuel.getItem();            return (Integer)createFuelTimeMap().getOrDefault(item, 0);        }    }    private int getCookTime(Level world, ForgeBlockEntity forge) {        Optional<RecipeHolder<ForgeRecipe>> recipe = getCurrentRecipe();        try {            BetterProgression.LOGGER.info("Cooking time fetched : " + recipe.get().value().getCookingTime());            return recipe.get().value().getCookingTime();        } catch (NoSuchElementException e) {            BetterProgression.LOGGER.error("Cook time fetch failed", e);            return 0;        }    }    public static boolean canUseAsFuel(ItemStack stack) {        return createFuelTimeMap().containsKey(stack.getItem());    }    private Optional<RecipeHolder<ForgeRecipe>> getCurrentRecipe() {        SimpleContainer inv = new SimpleContainer(this.getContainerSize());        for (int i = 0; i < this.getContainerSize(); i++) {            if (this.getItem(i) == ItemStack.EMPTY) {                inv.setItem(i, ModItems.EMPTY_SLOT.getDefaultInstance());            } else {                inv.setItem(i, this.getItem(i));            }        }        //BetterProgression.LOGGER.info("Checking current recipe: " + inv);        return getLevel().getRecipeManager().getRecipeFor(                ForgeRecipe.ForgeRecipeType.INSTANCE,                new ForgeRecipeInput(                        inv.getItem(INPUT1_SLOT),                        inv.getItem(INPUT2_SLOT),                        inv.getItem(UPGRADE_SLOT)        ), getLevel());    }    private static boolean canAcceptRecipeOutput(ItemStack itemStack, ForgeBlockEntity blockEntity) {        if (itemStack == null) {            return false;        } else {            return blockEntity.getItem(OUTPUT_SLOT).getItem() == itemStack.getItem() || blockEntity.getItem(OUTPUT_SLOT).isEmpty()                    && blockEntity.getItem(OUTPUT_SLOT).getCount() + itemStack.getCount() <= blockEntity.getItem(OUTPUT_SLOT).getMaxStackSize();        }    }    private boolean isOutputSlotEmptyOrReceivable() {        return this.getItem(OUTPUT_SLOT).isEmpty() || this.getItem(OUTPUT_SLOT).getCount() < this.getItem(OUTPUT_SLOT).getMaxStackSize();    }}